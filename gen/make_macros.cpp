#include <cstdlib>
#include <cstring>
#include <fstream>
#include <functional>
#include <iostream>
#include <string>
#include <sstream>
#include <type_traits>
#include <vector>

#pragma GCC diagnostic ignored "-Wpragmas" // Silence GCC warning about the next line disabling a warning that GCC doesn't have.
#pragma GCC diagnostic ignored "-Wstring-plus-int" // Silence clang warning about `1+R"()"` pattern.

#define VERSION "1.1.0"

namespace data
{
    // The amount of overloads of `MA_IDENTITYi`.
    constexpr int identity_overloads = 4;

    // Max number MA_VA_SIZE (and similar functions) can return.
    constexpr int size_max = 16;

    // The max amount of parameters CATn(...) can handle.
    constexpr int cat_max = 8;

    // Max length loops can handle.
    constexpr int loop_max = 64;

    // Max loop nesting level.
    constexpr int loop_nesting_max = 6;
}

namespace impl
{
    std::ofstream output_file;

    std::stringstream ss;
    const std::stringstream::fmtflags stdfmt = ss.flags();

    bool at_line_start = 1;
    int indentation = 0;
    int section_depth = 0;

    constexpr const char *indentation_string = "    ";

    void init(int argc, char **argv)
    {
        if (argc < 2)
        {
            std::cout << "Expected output file name.";
            std::exit(-1);
        }
        if (argc > 2)
        {
            std::cout << "Invalid usage.";
            std::exit(-1);
        }

        output_file.open(argv[1]);
        if (!output_file)
        {
            std::cout << "Unable to open `" << argv[1] << "`.\n";
            std::exit(-1);
        }
    }
}

template <typename ...P> [[nodiscard]] std::string make_str(const P &... params)
{
    impl::ss.clear();
    impl::ss.str("");
    impl::ss.flags(impl::stdfmt);
    (impl::ss << ... << params);
    return impl::ss.str();
}

void output_str(const std::string &str)
{
    for (const char *ptr = str.c_str(); *ptr; ptr++)
    {
        char ch = *ptr;

        if (ch == '}' && impl::indentation > 0)
            impl::indentation--;

        if (impl::at_line_start)
        {
            if (std::strchr(" \t\r", ch))
                continue;

            for (int i = 0; i < impl::indentation; i++)
                impl::output_file << impl::indentation_string;
            impl::at_line_start = 0;
        }

        impl::output_file.put(ch == '$' ? ' ' : ch);

        if (ch == '{')
            impl::indentation++;

        if (ch == '\n')
            impl::at_line_start = 1;
    }
}

template <typename ...P> void output(const P &... params)
{
    output_str(make_str(params...));
}

void section(std::string header, std::function<void()> func)
{
    output(header, "\n{\n");
    func();
    output("}\n");
}
void section_sc(std::string header, std::function<void()> func) // 'sc' stands for 'end with semicolon'
{
    output(header, "\n{\n");
    func();
    output("};\n");
}

void decorative_section(std::string name, std::function<void()> func)
{
    output("//{", std::string(impl::section_depth+1, ' '), name, "\n");
    impl::indentation--;
    impl::section_depth++;
    func();
    impl::section_depth--;
    output("//}", std::string(impl::section_depth+1, ' '), name, "\n");
    impl::indentation++;
}

void next_line()
{
    output("\n");
}

int main(int argc, char **argv)
{
    impl::init(argc, argv);

    { // Header
        output(1+R"(
            // macro.h
            // Preprocessor utils
            // Version )", VERSION, R"(
            // Autogenerated, don't touch.

            #pragma once
        )");
        next_line();
    }

    { // Macros
        { // Special
            output(1+R"(
                // Stops the compilation with a specific error message.
                // `msg` should be a string literal.
                // This implementation works on both GCC and Clang.
                #define MA_ABORT(msg) MA_ABORT_(GCC error msg)
                #define MA_ABORT_(msg) _Pragma(MA_STR(msg))
                // Same as `MA_ABORT`, but calling it with no parameters does nothing.
                #define MA_ABORT_IF_NOT_EMPTY(...) __VA_OPT__(MA_ABORT(__VA_ARGS__))
            )");
        }

        next_line();

        { // To string
            output(1+R"(
                // Stringifies `...`, while expanding any macros in it.
                #define MA_STR(...) MA_STR_impl(__VA_ARGS__)
                #define MA_STR_impl(...) #__VA_ARGS__
            )");
        }

        next_line();

        { // Concatenation
            output("// Concatenates all parameters, expanding any macros in them. The expansions can't contain commas.\n");
            for (int i = 2; i <= data::cat_max; i++)
            {
                std::string index_str;
                if (i > 2) index_str = make_str(i);

                output("#define MA_CAT", index_str, "(");
                for (int j = 1; j <= i; j++)
                {
                    if (j != 1) output(",");
                    output("p", j);
                }
                output(") MA_CAT", index_str, "_impl(");
                for (int j = 1; j <= i; j++)
                {
                    if (j != 1) output(",");
                    output("p", j);
                }
                output(")\n");
            }

            for (int i = 2; i <= data::cat_max; i++)
            {
                std::string index_str;
                if (i > 2) index_str = make_str(i);

                output("#define MA_CAT", index_str, "_impl(");
                for (int j = 1; j <= i; j++)
                {
                    if (j != 1) output(",");
                    output("p", j);
                }
                output(") ");
                for (int j = 1; j <= i; j++)
                {
                    if (j != 1) output("##");
                    output("p", j);
                }
                output("\n");
            }

            next_line();

            output(1+R"(
                // Concatenates `...` and `x`. Note that the parameters are in a different order.
                #define MA_APPEND_TO_VA_END(x,...) MA_APPEND_TO_VA_END_impl(x,__VA_ARGS__)
                #define MA_APPEND_TO_VA_END_impl(x,...) __VA_ARGS__##x
            )");
        }

        next_line();

        { // Misc
            output(1+R"(
                // Expands to nothing.
                #define MA_NULL(...)

                // Expands to `...`.
            )");

            for (int i = 1; i <= data::identity_overloads; i++)
                output("#define MA_IDENTITY", i == 1 ? "" : make_str(i), "(...) __VA_ARGS__\n");

            output(1+R"(

                // Expand to some basic symbols.
                #define MA_COMMA() ,
                #define MA_SEMICOLON() ;
                #define MA_PLUS() +

                // If `...` is not empty, adds a trailing comma to it.
                #define MA_TR_C(...) __VA_OPT__(__VA_ARGS__,)
                // If `...` is not empty, adds a leading comma to it.
                #define MA_LE_C(...) __VA_OPT__(,__VA_ARGS__)

                // Calls `m<i>(...)`, where `<i>` is the amount of comma-separated elements in `...`.
                #define MA_OVERLOAD(m,...) MA_CAT(m, MA_VA_SIZE(__VA_ARGS__))(__VA_ARGS__)

                // Expands to `a`, if `...` is not empty.
                #define MA_IF_NOT_EMPTY(a,...) __VA_OPT__(a)

                // Expands to `a`, if `...` is not empty. Otherwise expands to `b`.
                #define MA_IF_NOT_EMPTY_ELSE(a,b,...) MA_IF_NOT_EMPTY_ELSE_impl##__VA_OPT__(_a)(a,b)
                #define MA_IF_NOT_EMPTY_ELSE_impl(a,b) b
                #define MA_IF_NOT_EMPTY_ELSE_impl_a(a,b) a

                // If `a` is not empty, expands to `a`. Otherwise expands to `b`.
                #define MA_REPLACE_IF_EMPTY(a, b) MA_IF_NOT_EMPTY_ELSE(a, b, a)

                // If `...` is empty, expands to `x`, otherwise expands to nothing.
                #define MA_INVERT_EMPTINESS(...) MA_INVERT_EMPTINESS_impl##__VA_OPT__(_a)
                #define MA_INVERT_EMPTINESS_impl x
                #define MA_INVERT_EMPTINESS_impl_a

                // Expands to `a`, if `...` has at least one comma in it after expansion.
                #define MA_IF_COMMA(a,...) MA_IF_COMMA_impl(a,__VA_ARGS__,)
                #define MA_IF_COMMA_impl(a,unused,...) __VA_OPT__(a)

                // Expands to `a`, if `...` has at least one comma in it after expansion. Otherwise expands to `b`.
                #define MA_IF_COMMA_ELSE(a,b,...) MA_IF_COMMA_ELSE_impl(a,b,__VA_ARGS__,)
                #define MA_IF_COMMA_ELSE_impl(a,b,unused,...) MA_IF_COMMA_ELSE_impl_low##__VA_OPT__(_a)(a,b)
                #define MA_IF_COMMA_ELSE_impl_low(a,b) b
                #define MA_IF_COMMA_ELSE_impl_low_a(a,b) a
            )");
            // `OVERLOAD` shouldn't be used in this header internally, especially in loop implementations. (Since it can't be used recursively, and user might use it in their macros.)
        }

        next_line();

        { // Call a macro
            // This shouldn't be used in this header internally, especially in loop implementations. (Since it can't be used recursively, and user might use it in their macros.)
            output("// Same as `m(...)`, except `...` is expanded early, so any commas in it act as argument separators.\n");
            output("#define MA_CALL(m, ...) m(__VA_ARGS__)\n");
            // output("#define MA_IMPL_CALL(macro, ...) macro(__VA_ARGS__) // For implementation use\n");
        }

        next_line();

        { // Variadic access
            output(1+R"(
                // Expands to the first comma-separated element of `...`.
                #define MA_VA_FIRST(...) MA_VA_FIRST_impl(__VA_ARGS__,)
                #define MA_VA_FIRST_impl(x, ...) x

                // Expands to `...` with the first comma-separated element removed.
                #define MA_VA_NO_FIRST(x, ...) __VA_ARGS__
            )");
        }

        next_line();

        { // Sequence access
            output(1+R"(
                // `...` has to start with `(..)`. Expands to whatever is between the parens.
                #define MA_SEQ_FIRST(...) MA_SEQ_FIRST_impl __VA_ARGS__ )
                #define MA_SEQ_FIRST_impl(...) __VA_ARGS__ MA_NULL(

                // `...` has to start with `(..)`. Removes this pair of parens, and inserts a comma after them.
                #define MA_SEQ_SEP_FIRST(...) __VA_ARGS__,

                // `...` has to start with `(..)`. Inserts a comma after that `(..)`.
                #define MA_SEQ_SEP_FIRST_P(...) (__VA_ARGS__),

                // `...` has to start with `(..)`. Expands to `...` with this part removed.
                #define MA_SEQ_NO_FIRST(seq) MA_NULL seq

                // `seq` has to be a sequence, like `(a)(b)(c)`. Converts it to a variadic list, like `a,b,c`.
                #define MA_SEQ_TO_VA(seq) MA_APPEND_TO_VA_END(_end, MA_SEQ_TO_VA_impl_0 seq)
                #define MA_SEQ_TO_VA_impl_0(...)  __VA_ARGS__ MA_SEQ_TO_VA_impl_a
                #define MA_SEQ_TO_VA_impl_a(...) ,__VA_ARGS__ MA_SEQ_TO_VA_impl_b
                #define MA_SEQ_TO_VA_impl_b(...) ,__VA_ARGS__ MA_SEQ_TO_VA_impl_a
                #define MA_SEQ_TO_VA_impl_0_end
                #define MA_SEQ_TO_VA_impl_a_end
                #define MA_SEQ_TO_VA_impl_b_end

                // `seq` has to be a sequence, like `(a)(b)(c)`. Converts it to a variadic list without removing parens, like `(a),(b),(c)`.
                #define MA_SEQ_TO_VA_P(seq) MA_APPEND_TO_VA_END(_end, MA_SEQ_TO_VA_P_impl_0 seq)
                #define MA_SEQ_TO_VA_P_impl_0(...)  (__VA_ARGS__) MA_SEQ_TO_VA_P_impl_a
                #define MA_SEQ_TO_VA_P_impl_a(...) ,(__VA_ARGS__) MA_SEQ_TO_VA_P_impl_b
                #define MA_SEQ_TO_VA_P_impl_b(...) ,(__VA_ARGS__) MA_SEQ_TO_VA_P_impl_a
                #define MA_SEQ_TO_VA_P_impl_0_end
                #define MA_SEQ_TO_VA_P_impl_a_end
                #define MA_SEQ_TO_VA_P_impl_b_end
            )");
        }

        next_line();

        { // Variadic size
            output("// `...` has to be a comma-separated list. Expands the size of the list. (If the list is empty, expands to 1.)\n");
            output("#define MA_VA_SIZE(...) MA_VA_SIZE_impl(__VA_ARGS__");
            for (int i = data::size_max; i >= 0; i--)
                output(",", i);
            output(")\n");

            output("#define MA_VA_SIZE_impl(");
            for (int i = 1; i <= data::size_max; i++)
                output("p", i, ",");
            output("size,...) size\n");
        }

        next_line();

        { // Sequence size
            output("// `seq` has to be a sequence, like `(a)(b)(c)`. Returns the number of elements in it, which can be 0.\n");
            output("#define MA_SEQ_SIZE(seq) MA_CAT(MA_SEQ_SIZE_impl_0 seq, _val)\n");
            for (int i = 0; i <= data::size_max; i++)
                output("#define MA_SEQ_SIZE_impl_", i, "(...) MA_SEQ_SIZE_impl_", i+1, "\n");
            for (int i = 0; i <= data::size_max; i++)
                output("#define MA_SEQ_SIZE_impl_", i, "_val ", i, "\n");
        }

        next_line();

        { // For each variadic element
            output(1+R"(
                // Applies macro `m` to each comma-separated element in `...`.
                // A trailing comma in `...` is mandatory, not adding it causes an immediate error.
                // If your list doesn't have a trailing comma, wrap it in `MA_TR_C(...)`.
                // (Alternatively, you can add the comma manually. But in thsi case, if the list is empty, you'll get one unwanted iteration.)
                // `m` will be called as `m(d,i,x)`, where `d` is arbitrary user data, `i` is 0-based index, `x` is current element.
                // Is not reentrant (i.e. can't be nested in itself).
                #define MA_VA_FOR_EACH(d,m,...) __VA_OPT__(MA_VA_FOR_EACH_impl_minus1(d,m,__VA_ARGS__))
                // Nested loops. Similar to the regular version, but the indices start from `i+1` rather than `0`. (To start from `0`, pass `minus1`.)
                // `i` should be passed from the enclosing loop.
            )");

            for (int i = 1; i <= data::loop_nesting_max; i++)
                output("#define MA_VA_FOR_EACH_",i,"(i,d,m,...) __VA_OPT__(MA_CAT(MA_VA_FOR_EACH_impl_,i)(d,m,__VA_ARGS__))\n");
            next_line();

            output("#define MA_VA_FOR_EACH_impl_minus1(d,m,x,...) m(d,0,x) __VA_OPT__(MA_VA_FOR_EACH_impl_0(d,m,__VA_ARGS__))\n");

            for (int i = 1; i < data::loop_max; i++)
                output("#define MA_VA_FOR_EACH_impl_",i-1,"(d,m,x,...) m(d,",i,",x) __VA_OPT__(MA_VA_FOR_EACH_impl_",i,"(d,m,__VA_ARGS__))\n");
        }

        next_line();

        { // For each sequence element
            output(1+R"(
                // Similar to `MA_VA_FOR_EACH`, but operates on sequences like `(a)(b)(c)`.
                #define MA_SEQ_FOR_EACH(d,m,...) __VA_OPT__(MA_SEQ_FOR_EACH_impl_minus1(d,m,MA_SEQ_FIRST(__VA_ARGS__),MA_SEQ_NO_FIRST(__VA_ARGS__)))
            )");

            for (int i = 1; i <= data::loop_nesting_max; i++)
                output("#define MA_SEQ_FOR_EACH_",i,"(i,d,m,...) __VA_OPT__(MA_CAT(MA_SEQ_FOR_EACH_impl_,i)(d,m,__VA_ARGS__))\n");
            next_line();

            output("#define MA_SEQ_FOR_EACH_impl_minus1(d,m,x,...) m(d,0,x) __VA_OPT__(MA_SEQ_FOR_EACH_impl_0(d,m,MA_SEQ_FIRST(__VA_ARGS__),MA_SEQ_NO_FIRST(__VA_ARGS__)))\n");

            for (int i = 1; i < data::loop_max; i++)
                output("#define MA_SEQ_FOR_EACH_impl_",i-1,"(d,m,x,...) m(d,",i,",x) __VA_OPT__(MA_SEQ_FOR_EACH_impl_",i,"(d,m,MA_SEQ_FIRST(__VA_ARGS__),MA_SEQ_NO_FIRST(__VA_ARGS__)))\n");
        }

        /*

        { // Variadic to sequence (unnecessary)
            output("#define MA_VA_TO_SEQ(...) MA_CAT(MA_VA_TO_SEQ_impl_, MA_VA_SIZE(__VA_ARGS__,))(__VA_ARGS__,)\n");
            output("#define MA_VA_TO_SEQ_TRAILING_COMMA(...) MA_CAT(MA_VA_TO_SEQ_impl_, MA_VA_SIZE(__VA_ARGS__))(__VA_ARGS__)\n");
            output("#define MA_VA_TO_SEQ_impl_null\n");
            output("#define MA_VA_TO_SEQ_impl_1(empty) MA_VA_TO_SEQ_impl_null##empty // If you get a error message pointing to this line, you forgot a trailing comma somewhere.\n");
            for (int i = 1; i <= data::n; i++)
            {
                output("#define MA_VA_TO_SEQ_impl_", i+1, "("); // Note that the last macro generated by this line will have number n+1. This is intended, since there is one extra empty argument for the trailing comma.
                for (int j = 1; j <= i; j++)
                    output("p", j, ",");
                output("empty) ");
                for (int j = 1; j <= i; j++)
                    output("(p", j, ")");
                output(" MA_VA_TO_SEQ_impl_1(empty)\n");
            }
        }

        next_line();

        { // Sequence to variadic (unnecessary)
            output("#define MA_SEQ_TO_VA(seq) MA_CAT(MA_SEQ_TO_VA_impl_, MA_SEQ_SIZE(seq)) seq\n");
            output("#define MA_SEQ_TO_VA_impl_0\n");
            output("#define MA_SEQ_TO_VA_impl_1(...) __VA_ARGS__\n");
            for (int i = 2; i <= data::n; i++)
                output("#define MA_SEQ_TO_VA_impl_", i, "(...) __VA_ARGS__,MA_SEQ_TO_VA_impl_", i-1, "\n");
        }

        next_line();

        { // Sequence to variadic, preserve parens (replaced with a new implementation)
            output("#define MA_SEQ_TO_VA_PARENS(seq) MA_CAT(MA_SEQ_TO_VA_PARENS_impl_, MA_SEQ_SIZE(seq)) seq\n");
            output("#define MA_SEQ_TO_VA_PARENS_impl_0\n");
            output("#define MA_SEQ_TO_VA_PARENS_impl_1(...) (__VA_ARGS__)\n");
            for (int i = 2; i <= data::n; i++)
                output("#define MA_SEQ_TO_VA_PARENS_impl_", i, "(...) (__VA_ARGS__),MA_SEQ_TO_VA_PARENS_impl_", i-1, "\n");
        }

        next_line();

        { // For each variadic element
            output("// In MA_*_FOR_EACH below, `macro` argument is called as `macro(i, data, element)`. Note that to simplify implementation, `i` counts backwards from N-1 to 0.\n");

            next_line();

            for (const auto &suffix : data::suffixes)
            {
                output("#define MA_VA_FOR_EACH", suffix, "(macro, sep, data, ...) MA_SEQ_FOR_EACH", suffix, "(macro, sep, data, MA_VA_TO_SEQ(__VA_ARGS__))\n");
                output("#define MA_VA_FOR_EACH", suffix, "_TRAILING_COMMA(macro, sep, data, ...) MA_SEQ_FOR_EACH", suffix, "(macro, sep, data, MA_VA_TO_SEQ_TRAILING_COMMA(__VA_ARGS__))\n");
            }
        }

        next_line();

        { // For each sequence element
            bool first = 1;
            for (const auto &suffix : data::suffixes)
            {
                if (first)
                    first = 0;
                else
                    next_line();

                output("#define MA_SEQ_FOR_EACH", suffix, "(macro, sep, data, seq) MA_CAT(MA_SEQ_FOR_EACH", suffix, "_impl_, MA_SEQ_SIZE(seq))(macro, sep, data, seq)\n");
                output("#define MA_SEQ_FOR_EACH", suffix, "_impl_0(macro, sep, data, seq)\n");
                output("#define MA_SEQ_FOR_EACH", suffix, "_impl_1(macro, sep, data, seq) MA_IMPL_CALL", suffix, "(macro, 0, data, MA_SEQ_FIRST(seq))\n"); // Do not use IDENTITY instead of SEQ_FIRST here! Doing so might break it in the parameter macro.
                for (int i = 2; i <= data::n; i++)
                    output("#define MA_SEQ_FOR_EACH", suffix, "_impl_", i, "(macro, sep, data, seq) "
                           "MA_IMPL_CALL", suffix, "(macro, ", i-1, ", data, MA_SEQ_FIRST(seq)) sep() MA_SEQ_FOR_EACH", suffix, "_impl_", i-1, "(macro, sep, data, MA_SEQ_NO_FIRST(seq))\n");
            }
        }*/
    }

    if (!impl::output_file)
        return -1;
}
